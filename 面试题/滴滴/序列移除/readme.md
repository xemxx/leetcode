## 题目
这里当时因为时间关系，忘记复制题目了，，，就大概讲讲
给定三个值`n,total,cost`，以及两个序列`a,b`如下：
``` bash
5 10000 1000
1 5 4 2 3
5 4 3 2 1
```
每次可以在a和b中分别找一个数作为头，然后可以再找一个值相同的数为尾，然后删除头和尾组成的序列，没删除一次需要花费代价`cost`，并且获得一个红宝石

当不存在满足条件的序列后，将花费代价为剩下元素的个数的值，来消除剩下的元素，并且不能获得红宝石（PS：我觉得我没过的原因就是没看到最后还要花费剩下元素个数的代价，，，所以就没有算）

重点：`total`为可以花费的总代价

求：在能全部将元素消除的情况下，获得最大红宝石的数量

## 思路
一个核心思想：每次相同的值下标的间距最少，那样能获得红宝石的数量就最多

方法就是递归（回溯）：
- 我们的主要思路假设我们不存在一个`total`限定值，我们按照核心思想一直搜索到最后一个可互相匹配删除的位置，剩下的元素个数代表例如题目中的`a[3]=2,b[3]=2`，然后回溯，每次都保存当前为止可获得的总数量`count`和总花费的代价`costs`，直到代价大于总供给即`costs>total`，我们的`count`不再增加并且一直回溯
- 首先我们讨论怎么寻找最近的两个尾巴：
  - 需要用两个`map`来保存`a,b`两个数组的遍历过的值以及其下标如：`am[a[i]]=i`
  - 然后同时遍历两个数组，每次遍历判断某一个数组的当前值是否在另一个数组的`map`中，即：`_,ok:=am[b[i]];ok`（这里用的是golang写法，就是判断`am[b[i]]`是否存在），如果存在，我们分别删除两个数组之前的值，并且继续遍历，直到找不到为止
  - 上述情况是在没有`total`限制的情况，所以这里用到了递归，我们每次的删除操作变成递归操作即可，然后在回溯的时候做判断，即可解决`total`的限制问题
- 然后我们讨论怎么回溯，每次在递归后我们都会获得两个值：`count,costs`，`count`代表到目前为止，可以获得的总数量，`costs`代表到目前为止总花费的代价，然后我们也需要返回两个值，这时整个流程如下：
  - 首先在递归的开始，如果`len(a)==0 || len(b)==0`，代表我们已经递归到最后了，只需要到目前为止能获得的最大`count`和`costs`，很显然是`0`和`len(a)+len(b)`因为我们不确定哪个是0，所以相加即可
  - 然后执行上面的寻找两个尾巴即可，需要注意的是，因为是递归操作，所以每次找到第一个最近的两个尾巴，直接跳出循环进入回溯即可
  - 最后我们获得到目前为止的`count`和`costs`,则回溯开始：
    - 如果`costs+cost>total`代表这次删除是不可行的，那么我们返回`count,costs`
    - 如果`costs+cost<total`代表这次删除是可行的，那么我们返回`count+1,costs+cost`

最后要说的是，因为时间到了我也没有通过，所以我不确定上述思路一定正确，仅供参考

## 另一个方法
我的思路历程是这样的：
- 回溯就可以解决->
- 我对回溯不熟练，会浪费时间还是用迭代把，既然我不能正向找到最后的，那我反向就好了，当找到最后一个元素我直接跳出并减一就好了->
- 一直出错，只能通过50%，最后时间到了我发现我看错题目了，忘记计算多余的几个元素->
- 时间到了。。。

最后我采用回溯和迭代的方法分别写了出来，具体迭代可以参考：

``` golang
am, bm := map[int]int{}, map[int]int{}
count := 0
for i := 0; i < n; i++ {
    am[a[i]], bm[b[i]] = i, i
    last := 0
    if v, ok := bm[a[i]]; ok && v != -1 {
        for j := i; j >= 0; j-- {
            am[a[j]] = -1
        }
        for j := v; j >= 0; j-- {
            bm[b[j]] = -1
        }
        count++
        total -= cost
        last += (n - i) + (n - v)
    }
    if v, ok := am[b[i]]; ok && v != -1 {
        for j := v; j >= 0; j-- {
            am[a[j]] = -1
        }
        for j := i; j >= 0; j-- {
            bm[b[j]] = -1
        }
        count++
        total -= cost
        last += (n - i) + (n - v)
    }
    if total-last < cost {
        count--
        break
    }
}
fmt.Println(count)
```