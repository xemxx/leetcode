## 题目
给出一个长为n，宽为m的矩阵，以及k，矩阵中每个值为该位置的坐标相乘，如m*n，求该矩阵中第k大的数

## 思路
其实大小是有规律的，所以只需要判断一半的数值：
- 假设m>n，则需要每次减去`(n-m)+1+(n-m)`的数值，直到`k`的值小于0（或者说小于将要减去的数值），那么代表，k的防范围找到了，图形大概是一个长方形90度翻转重叠一个角的样子，然后由于对称性，每次减去2，直到`k<0`，这时k的取值要么为0要么为-1，并且最终的值就是最后一次减去的2所代表的值
- 如果n<m,那么只需要把n,m反转即可

画图的话我觉得很容易理解，之所以没过，因为我弄反了n和m的值，因为题目说`长为n，宽为m`，所以我选择了`arr[m][n]`这样的矩阵，是我阅读理解能力不够，我败了，，，

其次我在牛客上看到有人出题解，参考一下：

- 最后一个n*m的二维矩阵，每一个数的值是横纵坐标的乘积，求第k大值，要求nlogn的复杂度。典型的二分check，check(mid)返回矩阵中小于mid的数，遍历矩阵每一列，第k列小于mid的数是min(n,mid/k)。再套上二分就行..
- 作者：viia
- 链接：https://www.nowcoder.com/discuss/241344?type=0&order=0&pos=7&page=0
- 来源：牛客网

其实我觉得这样的解法更适合矩阵内每列数值不定的情况，因为本题中说的坐标值相乘，所以我觉得我的解法更优，最大的时间复杂度不过O(k)甚至更低